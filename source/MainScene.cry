import Graphics2D;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = 640.0;
const Y_RES = 480.0;

const Y_BARRIER = 0.75 * Y_RES;

const PADDLE_RADIUS = 50.0;
const PADDLE_THICKNESS = 10.0;

const ROTATION_PER_FRAME = 0.05;
const MAX_ABS_ANGLE = 0.15 * Math.PI;

const BALL_RADIUS = 7.0;

const GRAVITY = 0.2;

const NEW_BALL_PERIOD = 500;

class MainScene : AbstractScene {
	field rotating = false;

	field paddlePos = new Point(X_RES / 2.0, (Y_RES - Y_BARRIER) / 2.0);
	field paddleLeftPos;
	field paddleRightPos;
	field paddleAngle = 0.0;

	field ballsPos = [];
	field ballsVel = [];

	field newBallTimer = NEW_BALL_PERIOD;

	constructor() {
		this.paddleLeftPos = new Point(this.paddlePos.x - PADDLE_RADIUS, this.paddlePos.y);
		this.paddleRightPos = new Point(this.paddlePos.x + PADDLE_RADIUS, this.paddlePos.y);
	}

	function update(inputManager, events) {
		// Spawn balls periodically.
		--this.newBallTimer;
		if (this.ballsPos.length == 0 || this.newBallTimer == 0) {
			this.ballsPos.add(new Point(Random.randomFloat() * X_RES, 0));
			this.ballsVel.add(new Vector(Random.randomFloat() * 2.0 - 1.0, 0.0));
			this.newBallTimer = NEW_BALL_PERIOD;
		}
		// Get new paddle position.
		mousePos = inputManager.getMousePosition();
		newPaddlePos = new Point(mousePos[0], mousePos[1]);
		if (newPaddlePos.x < 0.0) {
			newPaddlePos.x = 0.0;
		} else if (newPaddlePos.x > X_RES) {
			newPaddlePos.x = X_RES;
		}
		if (newPaddlePos.y < Y_BARRIER) {
			newPaddlePos.y = Y_BARRIER;
		} else if (newPaddlePos.y > Y_RES) {
			newPaddlePos.y = Y_RES;
		}
		// Paddle rotation.
		if (inputManager.isKeyPressed(KeyboardKey.A) && this.paddleAngle > -MAX_ABS_ANGLE) {
			this.paddleAngle -= ROTATION_PER_FRAME;
		}
		if (inputManager.isKeyPressed(KeyboardKey.D) && this.paddleAngle < MAX_ABS_ANGLE) {
			this.paddleAngle += ROTATION_PER_FRAME;
		}
		if (inputManager.isKeyPressed(KeyboardKey.S)) {
			if (Math.abs(this.paddleAngle) < ROTATION_PER_FRAME) {
				this.paddleAngle = 0.0;
			}
			if (this.paddleAngle > 0.0) {
				this.paddleAngle -= ROTATION_PER_FRAME;
			} else if (this.paddleAngle < 0.0) {
				this.paddleAngle += ROTATION_PER_FRAME;
			}
		}
		// Compute paddle endpoints.
		x = Math.cos(this.paddleAngle);
		y = Math.sin(this.paddleAngle);
		newPaddleLeftPos = new Point(this.paddlePos.x - x * PADDLE_RADIUS, this.paddlePos.y - y * PADDLE_RADIUS);
		newPaddleRightPos = new Point(this.paddlePos.x + x * PADDLE_RADIUS, this.paddlePos.y + y * PADDLE_RADIUS);
		// Update physics.
		for (i = 0; i < this.ballsPos.length; ++i) {
			// Update velocity.
			this.ballsVel[i].y += GRAVITY;
			// Update position.
			newBallPos = new Point(this.ballsPos[i].x + this.ballsVel[i].x, this.ballsPos[i].y + this.ballsVel[i].y);
			// Check for intersection with paddle.
			p0 = this.paddleLeftPos;
			p1 = newPaddleLeftPos;
			q0 = this.paddleRightPos;
			q1 = newPaddleRightPos;
			c0 = this.ballsPos[i];
			c1 = newBallPos;
			sweeps = whenLineSweepsPoint(new LineSegment(p0.minus(c0), p1.minus(c1)), new LineSegment(q0.minus(c0), q1.minus(c1)), new Point(0.0, 0.0));
			if (sweeps.length > 0) {
				for (hit : sweeps) {
					hitPos = new LineSegment(c0, c1).lerpAcross(hit.timeProportion);
					// Reflect velocity over the normal.
					n = new Vector(-Math.sin(this.paddleAngle), Math.cos(this.paddleAngle));
					d = this.ballsVel[i];
					r = d.minus(n.times(2 * d.dot(n)));
					this.ballsVel[i] = r;
					// Compute the ball's corrected position.
					this.ballsPos[i] = hitPos.plus(this.ballsVel[i].times(1.0 - hit.timeProportion));
				}
			} else {
				this.ballsPos[i] = newBallPos;
			}
			// Bounce off walls.
			if ((this.ballsPos[i].x > X_RES && this.ballsVel[i].x > 0.0) || (this.ballsPos[i].x < 0.0 && this.ballsVel[i].x < 0.0)) {
				this.ballsVel[i].x = -this.ballsVel[i].x;
			}
		}
		// Purge out-of-bounds balls.
		for (i = 0; i < this.ballsPos.length; ++i) {
			if (this.ballsPos[i].y > Y_RES) {
				this.ballsPos.remove(i);
				this.ballsVel.remove(i);
			}
		}
		// Update paddle position.
		this.paddlePos = newPaddlePos;
		this.paddleLeftPos = newPaddleLeftPos;
		this.paddleRightPos = newPaddleRightPos;
	}

	function render() {
		Graphics2D.Draw.fill(192, 192, 192);

		// Draw paddle area, below barrier.
		Graphics2D.Draw.rectangle
			( 0, Y_BARRIER
			, X_RES, Y_RES - Y_BARRIER
			, 255, 255, 255
			);

		// Draw paddle.
		x = Math.cos(this.paddleAngle);
		y = Math.sin(this.paddleAngle);
		Graphics2D.Draw.line
			( this.paddleLeftPos.x, this.paddleLeftPos.y
			, this.paddleRightPos.x, this.paddleRightPos.y
			, PADDLE_THICKNESS
			, 0, 0, 0
			);

		// Draw balls.
		for (i = 0; i < this.ballsPos.length; ++i) {
			Graphics2D.Draw.ellipse
				( this.ballsPos[i].x - BALL_RADIUS, this.ballsPos[i].y - BALL_RADIUS
				, 2.0 * BALL_RADIUS, 2.0 * BALL_RADIUS
				, 0, 0, 0
				);
		}
	}
}
