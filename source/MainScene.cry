import Audio;
import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = 640.0;
const Y_RES = 480.0;

// The y-coordinate of the top of the paddle area.
const Y_BARRIER = 0.5 * Y_RES;

const PADDLE_RADIUS = 50.0;
const PADDLE_THICKNESS = 10.0;

// The rate at which the paddle can rotate.
const ROTATION_RATE = 0.02;
// The maximum absolute value of the paddle's angle offset.
const MAX_ABS_ANGLE = 0.25 * Math.PI;

const BALL_RADIUS = 7.0;

// Downward ball acceleration per frame.
const GRAVITY = 0.025;

// The proportion of normal velocity preserved after a ball bounce.
const CONSERVATION_RATE = 0.96;

// The number of frames before a new ball is added.
const NEW_BALL_PERIOD = 500;
// The maximum initial horizontal speed of new balls.
const MAX_INITIAL_VX = 5.0;

// Proportion of paddle velocity transferred to balls on contact.
const VEL_TRANSFER = 0.2;

// The minimum (velicity * normal) required for maximum bounce sound and sparks.
const SPEED_THRESHOLD = 30.0;

// Maximum number of sparks generated by a single bounce.
const MAX_SPARKS = 60;
// Number of frames sparks live.
const SPARK_LIFETIME = 20;
// Average spark speed before applying random offset, as a factor of the ball's velocity.
const SPARK_MAX_SPEED = 0.75;
// The maximum offset to a spark's initial velocity as a factor of the ball's speed.
const SPARK_SPREAD = 0.25;
// Thickness of the line representing a spark.
const SPARK_THICKNESS = 1.0;
// The length of the line representing a spark, as a factor of its velocity.
const SPARK_LENGTH_FACTOR = 2.0;

class MainScene : AbstractScene {
	static field font = FontResource.fromSystem("Times New Roman").getRenderer().setSize(16);
	static field bounceSoundResource = Audio.SoundResource.loadFromResource("bounce.ogg");

	field rotating = false;

	field paddlePos = [X_RES / 2.0, (Y_RES - Y_BARRIER) / 2.0];
	field paddleLeftPos;
	field paddleRightPos;
	field paddleAngle = 0.0;

	field ballsPos = [];
	field ballsVel = [];

	field sparksPos = [];
	field sparksVel = [];
	field sparksTime = [];

	field newBallTimer = NEW_BALL_PERIOD;

	field maxBalls = 0;

	constructor() {
		this.paddleLeftPos = [this.paddlePos[0] - PADDLE_RADIUS, this.paddlePos[1]];
		this.paddleRightPos = [this.paddlePos[0] + PADDLE_RADIUS, this.paddlePos[1]];
	}

	function update(inputManager, events) {
		// Spawn balls periodically.
		--this.newBallTimer;
		if (this.ballsPos.length == 0 || this.newBallTimer == 0) {
			this.ballsPos.add([Random.randomFloat() * X_RES, 0]);
			this.ballsVel.add([MAX_INITIAL_VX * (Random.randomFloat() * 2.0 - 1.0), 0.0]);
			this.newBallTimer = NEW_BALL_PERIOD;
		}
		// Update max balls.
		this.maxBalls = Math.max(this.maxBalls, this.ballsPos.length);
		// Get new paddle position.
		mousePos = inputManager.getMousePosition();
		newPaddlePos = [mousePos[0], mousePos[1]];
		if (newPaddlePos[0] < 0.0) {
			newPaddlePos[0] = 0.0;
		} else if (newPaddlePos[0] > X_RES) {
			newPaddlePos[0] = X_RES;
		}
		if (newPaddlePos[1] < Y_BARRIER) {
			newPaddlePos[1] = Y_BARRIER;
		} else if (newPaddlePos[1] > Y_RES) {
			newPaddlePos[1] = Y_RES;
		}
		// Paddle rotation.
		if (inputManager.isKeyPressed(KeyboardKey.A) && this.paddleAngle > -MAX_ABS_ANGLE) {
			this.paddleAngle -= ROTATION_RATE;
		}
		if (inputManager.isKeyPressed(KeyboardKey.D) && this.paddleAngle < MAX_ABS_ANGLE) {
			this.paddleAngle += ROTATION_RATE;
		}
		if (inputManager.isKeyPressed(KeyboardKey.S)) {
			this.paddleAngle = 0.0;
		}
		// Compute paddle endpoints.
		x = Math.cos(this.paddleAngle);
		y = Math.sin(this.paddleAngle);
		newPaddleLeftPos = [this.paddlePos[0] - x * PADDLE_RADIUS, this.paddlePos[1] - y * PADDLE_RADIUS];
		newPaddleRightPos = [this.paddlePos[0] + x * PADDLE_RADIUS, this.paddlePos[1] + y * PADDLE_RADIUS];
		// Compute central paddle velocity.
		paddleVel = minus(newPaddlePos, this.paddlePos);
		// Update ball physics.
		for (i = 0; i < this.ballsPos.length; ++i) {
			// Update velocity.
			this.ballsVel[i][1] += GRAVITY;
			// Compute updated position if no collision.
			newBallPos = plus(this.ballsPos[i], this.ballsVel[i]);
			if (this.ballsVel[i][1] > 0.0) {
				// Check for collisions with falling balls only.
				sweeps = whenLineSweepsPoint
					( makeLineSegment
						( minus(this.paddleLeftPos, this.ballsPos[i])
						, minus(newPaddleLeftPos, newBallPos)
						)
					, makeLineSegment
						( minus(this.paddleRightPos, this.ballsPos[i])
						, minus(newPaddleRightPos, newBallPos)
						)
					, [0.0, 0.0]
					);
				if (sweeps.length > 0) {
					for (sweep : sweeps) {
						hitPos = lerpAcross(makeLineSegment(this.ballsPos[i], newBallPos), sweep[0]);
						// Reflect velocity over the normal, losing a little speed.
						n = [-Math.sin(this.paddleAngle), Math.cos(this.paddleAngle)];
						v = this.ballsVel[i];
						vDotN = dot(v, n);
						r = minus(v, times(n, (1.0 + CONSERVATION_RATE) * vDotN));
						// Transfer momentum from paddle.
						this.ballsVel[i] = plus(r, times(n, VEL_TRANSFER * dot(paddleVel, n)));
						// Compute the ball's corrected position.
						newBallPos = plus(hitPos, times(this.ballsVel[i], 1.0 - sweep[0]));
						// Play bounce sound and generate sparks based on reflection speed.
						speedFactor = vDotN > SPEED_THRESHOLD ? 1.0 : vDotN / SPEED_THRESHOLD;
						MainScene.bounceSoundResource.play(-0.5 + newBallPos[0] / X_RES).setVolume(speedFactor);
						// Generate sparks.
						nSparks = Math.floor(speedFactor * MAX_SPARKS);
						for (sparkIdx = 0; sparkIdx < nSparks; ++sparkIdx) {
							this.sparksPos.add(hitPos);
							sparkVel = times(this.ballsVel[i], SPARK_MAX_SPEED * Random.randomFloat());
							offset = SPARK_SPREAD * Random.randomFloat() * (dot(this.ballsVel[i], this.ballsVel[i])) ** 0.5;
							angle = 2 * Math.PI * Random.randomFloat();
							this.sparksVel.add(plus(sparkVel, [Math.cos(angle) * offset, Math.sin(angle) * offset]));
							this.sparksTime.add(SPARK_LIFETIME);
						}
					}
				}
			}
			// Update ball's position.
			this.ballsPos[i] = newBallPos;
			// Bounce off walls.
			if ((this.ballsPos[i][0] > X_RES && this.ballsVel[i][0] > 0.0) || (this.ballsPos[i][0] < 0.0 && this.ballsVel[i][0] < 0.0)) {
				this.ballsVel[i][0] = -this.ballsVel[i][0];
			}
		}
		// Update paddle position.
		this.paddlePos = newPaddlePos;
		this.paddleLeftPos = newPaddleLeftPos;
		this.paddleRightPos = newPaddleRightPos;
		// Purge out-of-bounds balls.
		for (i = 0; i < this.ballsPos.length; ++i) {
			if (this.ballsPos[i][1] > Y_RES) {
				this.ballsPos.remove(i);
				this.ballsVel.remove(i);
				--i;
			}
		}
		// Update sparks.
		for (i = 0; i < this.sparksPos.length; ++i) {
			if (this.sparksTime[i] == 0) {
				this.sparksPos.remove(i);
				this.sparksVel.remove(i);
				this.sparksTime.remove(i);
				--i;
				continue;
			}
			--this.sparksTime[i];
			this.sparksPos[i] = plus(this.sparksPos[i], this.sparksVel[i]);
		}
	}

	function render() {
		Graphics2D.Draw.fill(192, 192, 192);

		// Draw paddle area, below barrier.
		Graphics2D.Draw.rectangle
			( 0, Y_BARRIER
			, X_RES, Y_RES - Y_BARRIER
			, 255, 255, 255
			);

		// Draw paddle.
		x = Math.cos(this.paddleAngle);
		y = Math.sin(this.paddleAngle);
		Graphics2D.Draw.line
			( this.paddleLeftPos[0], this.paddleLeftPos[1]
			, this.paddleRightPos[0], this.paddleRightPos[1]
			, PADDLE_THICKNESS
			, 0, 0, 0
			);

		// Draw balls.
		for (i = 0; i < this.ballsPos.length; ++i) {
			if (this.ballsPos[i][1] < -BALL_RADIUS) {
				Graphics2D.Draw.triangle
					( this.ballsPos[i][0], 5
					, this.ballsPos[i][0] - 7, 19
					, this.ballsPos[i][0] + 7, 19
					, 0, 0, 0, 10000 / -this.ballsPos[i][1]
					);
			} else {
				Graphics2D.Draw.ellipse
					( this.ballsPos[i][0] - BALL_RADIUS, this.ballsPos[i][1] - BALL_RADIUS
					, 2.0 * BALL_RADIUS, 2.0 * BALL_RADIUS
					, 0, 0, 0
					);
			}
		}

		// Draw sparks.
		for (i = 0; i < this.sparksPos.length; ++i) {
			endPoint = plus(this.sparksPos[i], times(this.sparksVel[i], SPARK_LENGTH_FACTOR));
			Graphics2D.Draw.line
				( this.sparksPos[i][0], this.sparksPos[i][1]
				, endPoint[0], endPoint[1]
				, SPARK_THICKNESS
				, 0, 0, 0, 255.0 * this.sparksTime[i] / SPARK_LIFETIME
				);
		}

		// Draw max balls.
		if (this.ballsPos.length == this.maxBalls) {
			MainScene.font.setColor(0, 0, 0);
		} else {
			MainScene.font.setColor(128, 128, 128);
		}
		scoreText = MainScene.font.render(this.ballsPos.length + " | " + this.maxBalls + "  ");
		scoreText.draw(X_RES - scoreText.width, 0);
	}
}
