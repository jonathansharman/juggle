import Audio;
import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = 640.0;
const Y_RES = 480.0;

const Y_BARRIER = 0.5 * Y_RES;

const PADDLE_RADIUS = 50.0;
const PADDLE_THICKNESS = 10.0;

const ROTATION_RATE = 0.02;
const MAX_ABS_ANGLE = 0.15 * Math.PI;

const BALL_RADIUS = 7.0;

const GRAVITY = 0.12;

const CONSERVATION_RATE = 0.96;

const NEW_BALL_PERIOD = 500;
const MAX_INITIAL_VX = 10.0;

// Proportion of paddle velocity transferred to balls on contact.
const VEL_TRANSFER = 0.2;

// The minimum (velicity * normal) required to play the bounce sound at maximum volume.
const MAX_VOLUME_THRESHOLD = 25.0;

class MainScene : AbstractScene {
	static field font = FontResource.fromSystem("Times New Roman").getRenderer().setSize(16);
	static field bounceSoundResource = Audio.SoundResource.loadFromResource("bounce.ogg");

	field rotating = false;

	field paddlePos = new Point(X_RES / 2.0, (Y_RES - Y_BARRIER) / 2.0);
	field paddleLeftPos;
	field paddleRightPos;
	field paddleAngle = 0.0;

	field ballsPos = [];
	field ballsVel = [];

	field newBallTimer = NEW_BALL_PERIOD;

	field maxBalls = 0;

	constructor() {
		this.paddleLeftPos = new Point(this.paddlePos.x - PADDLE_RADIUS, this.paddlePos.y);
		this.paddleRightPos = new Point(this.paddlePos.x + PADDLE_RADIUS, this.paddlePos.y);
	}

	function update(inputManager, events) {
		// Spawn balls periodically.
		--this.newBallTimer;
		if (this.ballsPos.length == 0 || this.newBallTimer == 0) {
			this.ballsPos.add(new Point(Random.randomFloat() * X_RES, 0));
			this.ballsVel.add(new Vector(MAX_INITIAL_VX * (Random.randomFloat() * 2.0 - 1.0), 0.0));
			this.newBallTimer = NEW_BALL_PERIOD;
		}
		// Update max balls.
		this.maxBalls = Math.max(this.maxBalls, this.ballsPos.length);
		// Get new paddle position.
		mousePos = inputManager.getMousePosition();
		newPaddlePos = new Point(mousePos[0], mousePos[1]);
		if (newPaddlePos.x < 0.0) {
			newPaddlePos.x = 0.0;
		} else if (newPaddlePos.x > X_RES) {
			newPaddlePos.x = X_RES;
		}
		if (newPaddlePos.y < Y_BARRIER) {
			newPaddlePos.y = Y_BARRIER;
		} else if (newPaddlePos.y > Y_RES) {
			newPaddlePos.y = Y_RES;
		}
		// Paddle rotation.
		if (inputManager.isKeyPressed(KeyboardKey.A) && this.paddleAngle > -MAX_ABS_ANGLE) {
			this.paddleAngle -= ROTATION_RATE;
		}
		if (inputManager.isKeyPressed(KeyboardKey.D) && this.paddleAngle < MAX_ABS_ANGLE) {
			this.paddleAngle += ROTATION_RATE;
		}
		if (inputManager.isKeyPressed(KeyboardKey.S)) {
			this.paddleAngle = 0.0;
		}
		// Compute paddle endpoints.
		x = Math.cos(this.paddleAngle);
		y = Math.sin(this.paddleAngle);
		newPaddleLeftPos = new Point(this.paddlePos.x - x * PADDLE_RADIUS, this.paddlePos.y - y * PADDLE_RADIUS);
		newPaddleRightPos = new Point(this.paddlePos.x + x * PADDLE_RADIUS, this.paddlePos.y + y * PADDLE_RADIUS);
		// Compute central paddle velocity.
		paddleVel = newPaddlePos.minus(this.paddlePos);
		// Update physics.
		for (i = 0; i < this.ballsPos.length; ++i) {
			// Update velocity.
			this.ballsVel[i].y += GRAVITY;
			// Compute updated position if no collision.
			newBallPos = this.ballsPos[i].plus(this.ballsVel[i]);
			if (this.ballsVel[i].y > 0.0) {
				// Check for collisions with falling balls only.
				sweeps = whenLineSweepsPoint
					( new LineSegment
						( this.paddleLeftPos.minus(this.ballsPos[i])
						, newPaddleLeftPos.minus(newBallPos)
						)
					, new LineSegment
						( this.paddleRightPos.minus(this.ballsPos[i])
						, newPaddleRightPos.minus(newBallPos)
						)
					, new Point(0.0, 0.0)
					);
				if (sweeps.length > 0) {
					for (sweep : sweeps) {
						hitPos = new LineSegment(this.ballsPos[i], newBallPos).lerpAcross(sweep[0]);
						// Reflect velocity over the normal, losing a little speed.
						n = new Vector(-Math.sin(this.paddleAngle), Math.cos(this.paddleAngle));
						v = this.ballsVel[i];
						vDotN = v.dot(n);
						r = v.minus(n.times((1.0 + CONSERVATION_RATE) * vDotN));
						this.ballsVel[i] = r;
						// Transfer momentum from paddle.
						this.ballsVel[i] = this.ballsVel[i].plus(n.times(VEL_TRANSFER * paddleVel.dot(n)));
						// Compute the ball's corrected position.
						newBallPos = hitPos.plus(this.ballsVel[i].times(1.0 - sweep[0]));
						// Play bounce sound.
						MainScene.bounceSoundResource.play(-0.5 + newBallPos.x / X_RES)
							.setVolume(vDotN > MAX_VOLUME_THRESHOLD ? 1.0 : vDotN / MAX_VOLUME_THRESHOLD);
					}
				}
			}
			// Update ball's position.
			this.ballsPos[i] = newBallPos;
			// Bounce off walls.
			if ((this.ballsPos[i].x > X_RES && this.ballsVel[i].x > 0.0) || (this.ballsPos[i].x < 0.0 && this.ballsVel[i].x < 0.0)) {
				this.ballsVel[i].x = -this.ballsVel[i].x;
			}
		}
		// Purge out-of-bounds balls.
		for (i = 0; i < this.ballsPos.length; ++i) {
			if (this.ballsPos[i].y > Y_RES) {
				this.ballsPos.remove(i);
				this.ballsVel.remove(i);
				--i;
			}
		}
		// Update paddle position.
		this.paddlePos = newPaddlePos;
		this.paddleLeftPos = newPaddleLeftPos;
		this.paddleRightPos = newPaddleRightPos;
	}

	function render() {
		Graphics2D.Draw.fill(192, 192, 192);

		// Draw paddle area, below barrier.
		Graphics2D.Draw.rectangle
			( 0, Y_BARRIER
			, X_RES, Y_RES - Y_BARRIER
			, 255, 255, 255
			);

		// Draw paddle.
		x = Math.cos(this.paddleAngle);
		y = Math.sin(this.paddleAngle);
		Graphics2D.Draw.line
			( this.paddleLeftPos.x, this.paddleLeftPos.y
			, this.paddleRightPos.x, this.paddleRightPos.y
			, PADDLE_THICKNESS
			, 0, 0, 0
			);

		// Draw balls.
		for (i = 0; i < this.ballsPos.length; ++i) {
			if (this.ballsPos[i].y < -BALL_RADIUS) {
				Graphics2D.Draw.triangle
					( this.ballsPos[i].x, 5
					, this.ballsPos[i].x - 7, 19
					, this.ballsPos[i].x + 7, 19
					, 0, 0, 0, 10000 / -this.ballsPos[i].y
					);
			} else {
				Graphics2D.Draw.ellipse
					( this.ballsPos[i].x - BALL_RADIUS, this.ballsPos[i].y - BALL_RADIUS
					, 2.0 * BALL_RADIUS, 2.0 * BALL_RADIUS
					, 0, 0, 0
					);
			}
		}

		// Draw max balls.
		if (this.ballsPos.length == this.maxBalls) {
			MainScene.font.setColor(0, 0, 0);
		} else {
			MainScene.font.setColor(128, 128, 128);
		}
		scoreText = MainScene.font.render(this.ballsPos.length + " | " + this.maxBalls + "  ");
		scoreText.draw(X_RES - scoreText.width, 0);
	}
}
